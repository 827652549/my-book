# TCP/UDP
## TCP是什么
传输层控制协议（TCP Transport Control Protocol），是一种面向连接的、可靠的、基于字节流的传输层通信协议，是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。

TCP的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。通过三次握手建立连接；四次挥手断开连接。

TCP最核心的三个要素：

- 面向连接：客户端、服务端交换数据前，需要建立连接
- 可靠：通过特定机制，在不可靠的网络之上，确保报文准确送达
- 字节流：数据的最小单位为字节。至于字节中存储内容的含义，由于应用层的程序决定


## TCP和UDP的区别

- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
- TCP对系统资源要求较多，UDP对系统资源要求较少。
- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

## 为什么UDP有时比TCP更有优势?/UPD应用场景

UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。

- 网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。

- TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。

采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。

## TCP三次握手


最开始的时候，客户端和服务端都是Closed(关闭)状态，准备发送连接请求前，Server会进入LISTEN(监听)状态。

- **第一次握手：** 客户端(Client)会给服务端(Server)发送请求报文段，并指定同步序列号SYN = 1，ACK = 0， 初始序号为seq = x，（seq里面就是字节的序号），同时TCP的客户端进程进入SYN-SENT(同步已发送)状态。
- **第二次握手：** 服务端收到客户端发送的请求报文SYN后，会向客户端发送一个SYN报文作为应答，表示同意建立连接，同时指定了自己的SYN = 1， ACK = 1，还会向客户端发送seq = y，来表示自己的一个初始序号，同时也会告诉客户端下一次应该从哪开始发送的确认序号，由于客户端发送过来的初始序号seq = x, 所以确认序号ack = x + 1，这时，TCP的服务端进入SYN-RCVD(同步收到)状态。
- **第三次握手：** 客户端收到服务端的确认报文之后，会再次向服务端发送确认信息，表示已经收到。所以ACK = 1, seq = x + 1, ack = y + 1。TCP建立连接，客户端和服务器进入ESTAB-LISTEND(已建立连接状态)状态。

> ![wAqsLn.jpg](https://s1.ax1x.com/2020/09/05/wAqsLn.jpg)
>
> TCP协议还有一个特点就是面向字节流，它会把数据都分成一个个字节，然后进行分段传输，在分段传输的时候，每一段是由不同的字节序号组成的。
> 
> 介绍一下图中的一些字段：
> 
> - SYN：同步序列号，是用来建立连接的握手信号。
> - ack：确认序号，当ACK为1时，ack有效，当ACK为0时，ack无效。
> - seq：序号。
> - ACK：确认序号有效。
> - FIN: 结束标志，用来表示断开连接。


谢希仁著《计算机网络》--“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”

client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。

## TCP是三次握手，而不是两次或四次？

**假如两次握手：**

一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

客户端第一次向服务端发送了建立连接的请求报文段，有可能因为网络的原因滞留了，客户端就会认为这个请求失效了，会重新向服务端发送一个连接请求，然后服务器正常响应连接。在某个时间段，第一次发送的连接请求才到达了服务端，如果没有第三次握手确认，那么此时服务端会误认为客户端又发了一个新的连接请求，会再一次响应客户端，客户端收到响应请求，发现这个请求刚刚已经发过了，而且也收到了服务端的响应，就忽略这个请求，但此时的服务端却还一直等待客户端的响应，这样就会造成资源的浪费。

**假如四次握手：**

第三次握手，服务端最后一次收到客户端的响应请求之后，如果此时进行第四次握手的话，那么应该是服务端接着去响应刚刚收到的这个请求，这个请求不管失败还是成功，意义都不大。因为三次握手之后，客户端和服务端都已经知道了双方的发送和接收是正常的，是可以进行数据传输的，就不需要再次发送确认请求了

## 三次握手过程中可以携带数据吗？

第一次、第二次握手不可以携带数据，原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥问题。

## TCP四次握手

- **第一次挥手:** 客户端主动断开连接，向服务端发送FIN报文段，即连接释放报文段（FIN=1，序号seq=u），并且状态变为FIN-WAIT-1(终止等待1)。
- **第二次挥手:** 服务端收到客户端的FIN报文段，响应请求，也向客户端发送一个ACK = 1，seq = y, ack = u + 1(三次握手阶段已经解释过seq和ack，没看懂的可以重新看一遍) 的报文段，来表示自己已经收到了客户端的断开连接的请求报文，同时将自己的状态变为CLOSE-WAIT(关闭等待)。
> 客户端收到第二次的挥手报文之后，也会将自身的状态变为FIN-WAIT-2(关闭等待)，此时客户端已经断开了对服务端的连接，也就是说，客户端不能再向服务端发送数据了，但是服务端并没有断开连接，它仍然要向客户端发送未发送完的数据，即TCP处于半关闭状态，这也是为什么要四次挥手的原因。
- **第三次挥手:** 等待一段时间，当服务端将剩余数据发送完后，也会向客户端发送一个FIN = 1 的报文段，其中seq = w, ack = u + 1, ACK = 1，同时，自身进入LAST-ACK(最后确认)状态，来等待客户端的ACK。
- **第四次挥手:** 客户端收到服务端的断开释放报文段FIN，同样对它进行响应，向服务段发送ACK = 1 ，seq = u + 1, ack = w + 1的报文段，并且自身进入TIME-WAIT状态，一段时间过后，服务端收到客户端的响应报文，将自身状态变为Closed，客户端等待TIME-WAIT时间过后，也将变为Closed状态。四次挥手完毕，客户端和服务端断开连接。

![wALFFf.jpg](https://s1.ax1x.com/2020/09/05/wALFFf.jpg)

## 为什么最后一次挥手，客户端还要进入一个2MSL的TIME-WAIT状态？

MSL（Maximum Segment Lifetime）可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。TCP允许不同的实现可以设置不同的MSL值。

如果客户端最后一次挥手发送的确认请求报文，服务端没有收到的话，服务端就会认为，是因为它自己发送的FIN报文段没有发送出去，导致客户端没有收到，客户端没有收到，就不会给它发送确认请求报文，于是，服务器会再次发送FIN报文段，所以有一个时长为2MSL的等待时间。

## TCP为什么是四次挥手，而不是两次或三次？

因为 TCP 是全双工通信。
> **全双工**指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。

**如果是两次：**

收到客户端请求断开（FIN）信号时，只是意味着客户端不再发送数据了，但服务端未必所有数据都已经发送到客户端了，甚至服务器如果还有数据要传输，但客户端由于已经断开连接所以接收不到

**如果是三次：**

三次挥手之后，服务器发送断开连接的信号如果过程中出现了丢包，客户端无法确定服务器已经断开连接，另外，服务端也不确定客户端是否已经知道服务端断开连接了。所以，可能导致，服务端断开，而客户端还一直占用资源。

## TCP如何保证可靠性

- 三次握手，保证两端建立连接。
- 确认和重传：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- 数据校验：TCP报文头有校验和，用于校验报文是否损坏
- 数据合理分片和排序：
- 流量控制：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- 拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。
- TCP 的接收端会丢弃重复的数据。

## SYN攻击是什么？

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## TCP 短连接和长连接的区别

**短连接**：Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。

短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

**长连接**：Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。

长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。


## 什么是粘包、拆包？

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。

- 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
- 服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
- 服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；
- 服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。

如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。

## 为什么会发生粘包和拆包

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

## 粘包和拆包解决办法

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

- **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
- **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
- 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。

## 为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？

UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

## TCP如何提升网络利用率

TCP协议中提高网络利用率的机制主要有：Nagle算法，延迟确认应答，捎带应答。

**Nagle算法**：

发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。

- 已发送的数据都已经收到确认应答。
- 可以发送最大段长度的数据时。

**延迟确认应答：**

接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。

- 在没有收到 2*最大段长度的数据为止不做确认应答。
- 其他情况下，最大延迟 0.5秒 发送确认应答。
- TCP 文件传输中，大多数是每两个数据段返回一次确认应答。

**捎带应答：**

在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。
