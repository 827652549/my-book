
## Node/特点/优点
nodeJS 是一门单线程!异步!非阻塞语言!

## Node里的模块汇总

这里汇总nodeV12.16.2版本的稳定模块，排除了不稳定或者废弃的模块

|模块|说明|
|-|-|
|assert（断言）|提供断言测试（一般assert用于捕捉程序员自己的错误，Error/Exception捕捉用户或者环境的错误）|
|async_hooks（异步钩子）|用于跟踪应用的异步资源|
|Buffer（缓冲器）|处理二进制数据|
|child_process（子进程）|衍生出子进程来操作|
|cluster（集群）|创建共享服务器端口的子进程，充分利用多核系统|
|console（控制台）|提供简单的调试控制台，类似于web浏览器提供的JavaScript控制台|
|crypto（加密）|提供加密功能，包括对OpenSSL的哈希、HMAC、加密、解密、签名、验证功能的一套封装|
|debugger（调试器）|进程外的调试程序，相当于IDE里的调试功能|
|dgram（数据报）|提供了UDP数据包socket实现|
|dns（域名服务器）|用于启用域名解析|
|Error（错误）|js运行或执行底层过程中抛出的错误|
|events（事件触发器）|绑定事件和触发事件|
|fs（文件系统）|与文件系统进行交互|
|global（全局变量）|全局变量，它的属性都是全局变量，相当于浏览器中的windows|
|http（HTTP）|实用HTTP服务器和客户端|
|http2（HTTP/2）|提供了HTTP/2协议的实现|
|https（HTTPS）|提供了HTTPS（TLS/SSL的HTTP协议）实现|
|module（模块）|实现模块化|
|net（网络）|创建基于流的TCP或IPC服务器和客户端|
|os（操作系统）|提供了与操作系统相关的方法和属性|
|path（路径）|处理文件与目录路径的工具|
|perf_hooks（性能钩子）|监控性能、测量异步操作时长|
|process（进程）|提供当前进程的信息并对其控制|
|querystring（查询字符串）|对HTTP请求所带的数据进行解析|
|readline（逐行读取）|可一行一行读取流|
|repl（交互式解释器）|提供了一种“读取-求职-输出”的循环实现，相当于在控制台直接启动node的`>`操作|
|stream（流）|处理流式数据的对象|
|string_decoder（字符串解码器）|安全地将Buffer对象解码为字符串|
|timer（定时器）|实现了与浏览器API类似的定时器|
|tls（安全传输层）|安全传输层（TLS）及安全套接层（SSL）协议实现，建立在OpenSSL基础上|
|tty（终端）|提供了tty.ReadStream和tty.WriteStream，大多数情况下用户不必手动创建这两个类的实例|
|url（URL）|处理和解析URL|
|util（实用工具）|提供了转换回调风格、调试输出、废弃API等相关的工具|
|v8（V8引擎）|暴露了Node底层二进制文件中的V8版本API|
|vm（虚拟机）|在V8虚拟机上下文中编译和运行代码|
|worker_threads（工作线程）|允许使用并行地执行JavaScript的线程|
|zlib（压缩）|实现压缩功能|

## 为什么要用Node

- 简单强大，轻量可扩展．简单体现在node使用的是javascript,json来进行编码，人人都会；
- 强大体现在非阻塞IO,可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；
- 轻量体现在node本身既是代码，又是服务器，前后端使用统一语言;
- 可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件．

## 什么用Nodejs,它有哪些优缺点？
简单强大，轻量可扩展

- 简单体现在node使用的是javascript,json来进行编码，人人都会；
- 强大体现在非阻塞IO,可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；
- 轻量体现在node本身既是代码，又是服务器，前后端使用统一语言;
- 可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件．
- 不用担心多线程，锁，并行计算的问题
- V8引擎速度非常快

缺点：
- nodejs更新很快，可能会出现版本兼容，比如node的事件循环11版本前后就发生了变化
- nodejs还不算成熟，还没有大制作
- nodejs不像其他的服务器，对于不同的链接，不支持进程和线程操作

## 什么是错误优先的回调函数？

错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。第一个参数返回错误，并且验证它是否出错；其他参数返回数据。
```javascript
fs.readFile(filePath, function(err, data)
  {
      if (err)
      {
          // 处理错误
          return console.log(err);
      }
      console.log(data);
  });
```

## node架构
主要分为三层，应用app >> V8及node内置架构 >> 操作系统. 

V8是node运行的环境，可以理解为node虚拟机．

node内置架构又可分为三层: 核心模块(javascript实现) >> c++绑定 >> libuv + CAes + http.

## node有哪些核心模块?
EventEmitter, Stream, FS, Net和全局对象

## 事件循环机制在Node和浏览器中有什么区别

浏览器和Node 环境下，microtask 任务队列的执行时机不同

- Node端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

node版本大于11的，和浏览器表现一致，小于11的，会有这样的策略：若第一个定时器任务出队并执行完，发现队首的任务仍然是一个定时器，那么就将微任务暂时保存，直接去执行新的定时器任务，当新的定时器任务执行完后，再一一执行中途产生的微任务。

## process.nextTick

process.nextTick 是一个独立于 eventLoop 的任务队列。

在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。

## npm模块install机制和原理
**npm 模块安装机制**：

- 发出npm install命令
- 查询 node_modules 目录之中是否已经存在指定模块
- 若存在，不再重新安装
- 若不存在
- npm 向 registry 查询模块压缩包的网址
- 下载压缩包，存放在根目录下的.npm目录里
- 解压压缩包到当前项目的 node_modules 目录

**npm 实现原理**：

输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）：

- 执行工程自身 preinstall，当前 npm 工程如果定义了 preinstall 钩子此时会被执行。
- **确定首层依赖模块**，首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。
- **获取模块**，获取模块是一个递归的过程，分为以下几步：
	- 获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。
	- 获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。
	- 查找该模块依赖，如果有依赖则回到第1步，没有则停止。
- **安装模块**，这一步将会更新工程中的 node_modules ，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。
- **执行工程自身生命周期**，当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。

最后一步是生成或更新版本描述文件，npm install 过程完成。

**模块扁平化（dedupe）**：

- 上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。
- 从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。
- 这里需要对重复模块进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。
- 比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 ^1.1.0 为兼容版本。
- 而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。

## npm版本号

A.B.C

- A是大版本号，进行不兼容变更的主要版本，
- B是小版本号，向下兼容的方式**添加功能**小版本
- C是布丁版本号，向后兼容时bug修复的补丁版本

- `^2.2.1` 大版本号为2，小版本号大于等于2，补丁版本号大于等于1
- `~2.2.1` 大版本号为2，小版本号为2，补丁版本号大于等于1
- `>2.1` 大于2.1的所有版本，不包括2.1，也可以使用<、<=等等
- `1.0.0 - 1.2.0`，范围的所有版本
- `1.0.0-rc.1` 包括预发行的特定版本
- `^2 <2.2 || > 2.3` 可以用||逻辑判定
- `>=1.0.0-rc.0 <1.0.1` 指定一系列预发行版本

## 中间件/洋葱模型

中间件 在 Node.js 中被广泛使用，它泛指一种特定的设计模式、一系列的处理单元、过滤器和处理程序，以函数的形式存在，连接在一起，形成一个异步队列，来完成对任何数据的预处理和后处理。

它的优点在于 灵活性：使用中间件我们用极少的操作就能得到一个插件，用最简单的方法就能将新的过滤器和处理程序扩展到现有的系统上。

常规中间件模式：最基础的组成部分就是 中间件管理器，我们可以用它来组织和执行中间件的函数，

- 可以通过调用use()函数来注册新的中间件
- 当接收到需要处理的新数据时，在注册的中间件中依次调用。每个中间件都接受上一个中间件的执行结果作为输入值；
- 每个中间件都可以停止数据的进一步处理，只需要简单地不调用它的回调函数或者将错误传递给回调函数。当发生错误时，通常会触发执行另一个专门处理错误的中间件。

至于怎么处理传递数据，目前没有严格的规则，一般有几种方式：

- 通过添加属性和方法来增强；
- 使用某种处理的结果来替换 data；
- 保证原始要处理的数据不变，永远返回新的副本作为处理的结果。

而具体的处理方式取决于 中间件管理器 的实现方式以及中间件本身要完成的任务类型。

**洋葱模型的实现原理：**

形象思维：一层一层往里进，再一层一层往外出

中间件的实现原理，也就是洋葱模型的实现原理，核心在于next的实现。next需要依次调用下一个middleware，当到最后一个的时候结束，这样后面middleware的promise先resolve，然后直到第一个，这样的流程也就是洋葱模型的流程了。

**缺点：**

中间件模型非常好用并且简洁, 甚至在 koa 框架上大放异彩, 但是也有自身的缺陷, 也就是一旦中间件数组过于庞大, 性能会有所下降, 因此我们需要结合自身的情况与业务场景作出最合适的选择.

