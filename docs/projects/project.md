面试官提问的时候，更多倾向于提问：

（腾讯夺命连环问）
-  说一下你在这个项目中主要负责什么？
-  看到你用到了XXX，为什么使用XXX？
-  除了XXX你还知道什么类似的框架/库/脚本？//回答AAA
-  AAA和XXX有什么区别？
-  为什么不使用AAA而使用XXX？


## 直播的解决方案

使用过的解决方案：先用vlc执行rtsp协议来读取摄像头视频数据，测试成功。后来找到一个叫做JavaCV的库，它实现了OpenCV, FFmpeg等等。然后通过这个库可以在Java中设置请求连接rtsp，获取到视频流。
后来也写了保存成录像，后来使用了阿里云的对象存储OSS，设置文件为可写策略，通过阿里云API进行调用并执行"追加上传"的功能，不同于其他文件系统的覆盖上传，它是可以直接在文件对象后追加数据，也正是因此方便了这种类似直播功能的实现。

其实这个项目是一个"远程自动控制机器手臂"的javafx项目，通过远程视频监控拖动滑动条组件进行数据信号控制运动，并添加机械手臂的保存功能。


## 购物车，打开多个窗口/tap，如果让数据保持同步

就比如商城页面打开两个，第一个窗口里添加商品，第二个窗口怎么能同步更新

**方案一：localStorage**：

**简要概述：**

数据存储在localStorage，监听storage，在数据变动时能够在storage事件的event参数中识别和获取到变动的数据，进而带动数据的同步。

**详细阐述：**

localStorage只能实现同一浏览器相同域名、相同协议、相同端口下的多个标签页之间的通信。不同浏览器没有该效果。

localStorage是Storage对象的实例。对Storage对象进行任何修改，都会在文档上触发storage事件。当通过属性或者setItem()方法保存数据，使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会发生该事件。

storage事件的event对象有以下属性：

- domin：发生变化的存储空间的域名；
- key：设置或者删除的键名；
- newValue：如果是设置值，则为新值；如果是删除值，则是null；
- oldValue：键被更改之前的值；

**方案二：cookie+setInterval**:

**简要概述：**

一个页面产生的cookie能被这个页面的统一目录和子目录下的页面访问，通常把cookie的path设置为一个更高级别的目录，从而使更多的页面共享cookie，实现多页面之间相互通信。然后通过setInterval进行轮询获取cookie并加以处理

**额外补充：**

cookie的参数：

- path：cookie所在的目录，默认为/，即根目录， 通常用来解决同域下cookie的访问问题
- domain ：cookie所在的域，默认为请求的地址，通过设置document.domain可以实现跨域访问

## 设计百度输入框的思路，用到哪些属性和事件

**UI：**

- flex垂直居中布局，引入logo，和input框、搜索button、隐藏的搜索展示区div用display:none隐藏
- 搜索展示区的li样式要添加上hover文字高亮

**事件：**

- button的onclick事件，请求对应的搜索展示页
- input的onkeyup事件，每次键盘松开的时候进行请求联想列表，将获取的列表在搜索展示区div里用ul展示，并将div的display展示成可见的，这个输入过程可以用防抖优化
- input的onkeydown事件，判断e.keyCode等于13（代表回车）的情况，同样请求对应的搜索页
- 列表li的onclick事件，获取当前的列表内容，并请求对应搜索页
- body的onclick事件，鼠标点击主要搜索区域之外的位置时，让联想区div进行不可见，不过对应的要在input和button事件代码里通过e.stopPropagation()阻止冒泡

## 怎么在海量数据中找出重复次数最多的一个？

比如：海量日志中ip的统计出现次数最多的那个

**核心思想：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求**

**详细逻辑：** 
假设是一个大文件，基于对内存的限制，首先要对于日志进行拆分成小文件，然后统计小文件中的ip最后得到汇总数据。

- 分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决
- hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。
- 堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。

> 1、Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模（如模1000），必定仍然相等。      
> 2、**hash映射**:简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。

**上云方案：**

这个场景我们可以考虑使用云服务，说一下我了解的阿里云的服务，例如阿里云的批量计算，我们可以将日志文件存储到OSS中，利用它可以弹性扩大文件的特性，通过追加上传的方式不断地向日志文件添加新内容。最后，我们可以直接利用阿里云批量计算服务，将数据进行拆分，然后交给云端分布式并发计算，最后marge合并返回最终结果。

不过最好是对每日的文件按照规模进行存储，比如每个日志文件超过50m就进建新log文件，以日期和时间命名，分别放到每日的文件夹中，方便检索和提取。

## 亿级别数据排序

有最多**1000万**条**不一样的整型**数据存在于硬盘的文件中（数据不超过最大值），如何在**1M内存**的状况下对其进行尽量快的排序。

- 数据特征：单个数据<=1000万、不一样的（没有重复）、整型（int，4B）
- 要求：1M内存、尽量快
- 分析：1MB = 1*1024*1024 B   能存储大于25万个int类型的整数。因此每次咱们能够排序25万条记录，一共排序40次。

一个简单的思路是读1000万条1次，对第i个25万条数据进行排序，并将排好的结果存成外部文件i（这里能够用常见的内部排序，如快排），最后咱们生成了40个排好序的外部文件，而后对这40个文件进行归并排序输出成1个文件。

> chrome里Array.sort()长度小于10的数组是插入排序，大于10的数组是快速排序。

##  上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。

**核心方案：** 上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后利用堆取出前N个出现次数最多的数据。

#### 寻找热门查询，300万个查询字符串中统计最热门的10个查询

采用hashmap + 堆

1. hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；
2. 堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N' * O（logK），（N为1000万，N’为300万）。

#### 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。

**‌如果每个数据元素只出现一次，而且只出现在某一台机器中：**

1. 堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP10大）。
2. 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。

**‌但如果同一个元素重复出现在不同的电脑中呢:**

- **方法一：** 遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP10，继而组合100台电脑上的TOP10，找出最终的TOP10。
- **方法二：** 暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP10。

## 大文本文件，每行一个词，要求统计频繁出现的前10个词，请给出思想，给出时间复杂度分析。

- 方案1：如果文件比较大，无法一次性读入内存，可以采用hash取模的方法，将大文件分解为多个小文件，对于单个小文件利用hash_map统计出每个小文件中10个最常出现的词，然后再进行归并处理，找出最终的10个最常出现的词。
- 方案2：通过hash取模将大文件分解为多个小文件后，除了可以用hash_map统计出每个小文件中10个最常出现的词，也可以用trie树统计每个词出现的次数，时间复杂度是O(n\*le)（le表示单词的平准长度），最终同样找出出现最频繁的前10个词（可用堆来实现），时间复杂度是O(n\*lg10)。

#### 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

- 分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
- hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。
- 堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。

#### 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

- hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
- hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。
- 堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。

## 连个大文件，找出共同的url

#### 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

- 分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为， 这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
- hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
